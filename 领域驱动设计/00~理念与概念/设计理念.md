# 设计理念

领域驱动设计（DDD）的核心战略是将问题域与应用架构分离，突出业务语义。它将复杂的业务逻辑通过领域对象和统一语言转化为清晰的领域概念。DDD 的目标是隔离业务逻辑和技术实现的复杂度，确保它们之间的边界清晰。理想情况下，业务逻辑应与技术实现保持正交关系。DDD 通过分层架构和六边形架构来实现这一目标。

DDD 的关键理念包括：

1. 统一语言：确保所有参与者使用一致的术语，建立清晰的业务模型和统一的业务语义。这种语言应贯穿于团队交流、代码、图表和文档中，提高代码可读性，减少认知成本。例如，"账号"、"转账"、"透支策略"等领域概念应与日常讨论和需求文档保持一致。

2. 面向领域：强调以领域思考问题，而非模块。将隐含的业务逻辑从复杂的条件语句中提取出来，使用统一语言命名和编码，使其成为显式概念。

3. 职责划分：根据实际业务合理划分模型，明确模型间的依赖关系和边界，提高可读性和可维护性。遵循单一职责原则，避免模型之间的越权调用。通过建模更好地表达复杂业务，随时间推移不断完善系统对实际业务的理解。

DDD 鼓励在接触需求时首先考虑领域模型，而不是将其分割为数据和行为。以银行账号（Account）为例，传统方法可能将"存款"、"计算利息"和"取款"等行为放在 AccountService 中，而 DDD 建议将这些行为直接放在 Account 对象中。这种方法强调业务抽象和面向对象编程，而非过程式的业务逻辑实现。

通过领域模型和分层思想，DDD 旨在屏蔽外部变化对领域逻辑的影响，确保交付的是边界清晰的微服务，而非内部混乱的小型单体应用。这种方法使得在需求和设计变化时，能够轻松地进行微服务的开发、拆分和组合，保证微服务的稳定运行和抗干扰能力。DDD 让开发者首先考虑的是业务语言，而不是数据，从而更好地应对复杂的业务需求和频繁的变化。

## 设计原则

DDD 的设计原则包括以下几个方面:

- Focusing on the Core Domain: DDD 强调将主要精力集中在核心子域上，因为核心子域是产品成败的关键，是产品的独特卖点和竞争优势所在。所有团队都需要深入理解核心领域的重要性。

- Learning through Collaboration: DDD 重视开发团队和业务专家之间的紧密合作。通过协作和知识共享，可以对问题领域有更深入的理解，并产生更有效的解决方案模型。

- Creating Models through Exploration and Experimentation: DDD 将分析模型和代码模型视为一个整体，鼓励团队通过探索和实验来创建和改进模型。这种方法可以带来突破性的进展，有助于塑造更好的设计。

- Communication: 有效沟通是 DDD 的基础。创建统一语言(UL)是 DDD 最重要的方面之一，它确保业务团队和开发团队之间能够进行有效的协作和知识共享。

- Understanding the Applicability of a Model: DDD 强调每个模型都应在特定上下文中理解和使用。通过确保每个模型都有自己的 UL 和明确的应用范围，可以避免语言的歧义和模型的混淆。

- Constantly Evolving the Model: DDD 鼓励团队不断审视和改进模型。随着对领域理解的深入和新业务需求的出现，模型需要持续演化和简化，以保持其有效性和可维护性。

这些原则共同构成了 DDD 的核心思想，指导团队如何更好地理解、设计和实现复杂的业务系统。

# DDD 价值

Eric Evans 在创造性地提出领域驱动设计时，实则是针对当时项目中聚焦在以数据以及数据样式为核心的系统建模方法的批判。面向数据的建模方法是关系数据库理论的延续，关注的是数据表以及数据表之间关系的设计。这是典型的面向技术实现的建模方法，面对日渐复杂的业务逻辑，这种设计方法欠缺灵活性与可扩展性，也无法更好地利用面向对象设计思想及设计模式，建立可重用的、可扩展的代码单元。领域驱动设计的提出，是设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程。

## 应对复杂业务

引起软件系统复杂度的主要因素是需求，软件系统需求又可以分两个方面：业务需求和技术需求。我们分析系统的复杂度时就可以从业务复杂度和技术复杂度这两个维度出发。

业务复杂度跟系统的业务需求规模和需求之间的关系层级有直接关系，需求的数量和关系的层级决定代码的规模和逻辑循环或递归的层级，系统的需求数量越大，需求之间的关系越复杂，系统的业务复杂度就越大。John Ousterhout 的著作《A Philosophy of Software Design》从认知的负担和开发工作量的角度来定义软件系统的复杂度，并给出了一个复杂度公式：

$$
C=\sum_{p} \mathrm{C}_{p} \mathrm{t}_{p}
$$

子模块的复杂度（cp）乘以该模块对应的开发时间权重值（tp），累加后得到系统的整体复杂度（C）。可以看到系统整体的复杂度并不简单等于所有子模块复杂度的累加，还要考虑该模块的开发维护所花费的时间在整体时间中的权重占比（tp），这个权重比就跟模块划分是否内聚、设计是否优雅有直接关系。

DDD 的核心思想就是要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，确定业务逻辑与技术实现的边界，从而隔离各自的复杂度，业务逻辑并不关心技术是如何实现的。无论采用何种技术，只要业务需求不变，业务规则就不会变化。理想状态下，应该保证业务逻辑与技术实现是正交的。DDD 通过分层架构与六边形架构确保业务逻辑与技术实现的隔离。

## 快速响应业务变化

不确定性和变化是这个时代的主旋律，业务需要快速上线，并根据用户的反馈不停地调整和升级，有生命力的业务主动寻求变化，不变则亡是很多行业目前的共识，企业应对变化的响应力成了成败的关键。同时一个长期困扰软件研发的问题是，需求总是在变化，无论预先设计如何“精确”，总是发现下一个坑就在不远处。相信很多技术人员都有这样的经历，架构和响应能力越来越糟糕，也就是我们常说的架构腐化了，最后大家不得不接受重写。软件架构设计的另一个关键方面是让系统能够更快地响应外界业务的变化，并且使得系统能够持续演进。在遇到变化时不需要从头开始，保证实现成本得到有效控制。

DDD 的核心是从业务出发、面向业务变化构建软件架构，实质是保证面对业务变化时我们能够有足够快的响应能力。面向业务变化而架构就要求首先理解业务的核心问题，即有针对性地进行关注点分离来找到相对内聚的业务活动形成子问题域。让每个字问题的划分尽可能靠近变化的原点，子问题域内部是相对稳定的，未来的变化频率不会很高，是符合深模块特性的，而子问题边界是很容易变化的。DDD 最后在实现层面利用成熟的技术模式屏蔽掉技术细节的复杂度。

## 与微服务相得益彰

Martin Fowler 和 James Lewis 提出微服务时，提出了微服务的 9 大架构特质，指导组织围绕业务组建团队，把业务拆分为一个个业务上高度内聚、技术上松散耦合、运行在独立进程中的小型服务，微服务架构赋予了每个服务业务上的敏捷性和技术上的自主性，因此可以针对每个服务进行独立地迭代、更新、部署和弹性扩展，从而缩短需求交付周期并加速创新。

在面对复杂业务和快速变化需求时，DDD 从业务视角进行关注点分离和应对复杂度的，让业务具备更高的响应力。DDD 战略设计阶段，引入限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，确定领域的边界以及它们之间的关系，维持模型的完整性。限界上下文不仅限于对领域模型的控制，而在于分离关注点之后，使得整个上下文可以成为独立部署的设计单元，这就是“微服务”的概念，上下文映射的诸多模式则对应了微服务之间的协作。因此在战略设计阶段，微服务扩展了领域驱动设计的内容，反过来领域驱动设计又能够保证良好的微服务设计。边界给了实现限界上下文内部的最大自由度。这也是战略设计在分治上起到的效用，我们可以在不同的限界上下文选择不同的架构模式和技术实现，这也正好映照了微服务的特点：在技术架构上，系统模块之间充分解耦，可以自由地选择合适的技术架构，去中心化地治理技术和数据。

Thought Works 公司技术专家编写的《微服务设计》书中，专门有一章节“限界上下文”，充分说明微服务的落地需要 DDD 来辅助的，起码在建模阶段是需要借助 DDD 强大的战略模式来支撑的。微服务不是简单的指将服务尽可能的拆小，然后一个 RPC 框架搞定了，这太粗糙了，无法落地。

![微服务与 DDD 关联](https://s3.ax1x.com/2021/02/04/y19mdA.png)

## 辅助中台战略落地

领域驱动设计让参与者基于统一语言沟通和协作，围绕一个统一和一致的领域模型工作，传统的分析模型和设计模型不再割裂；显式地把业务领域和设计放到了软件开发的核心，软件人员和业务人员合作来构建领域模型，使得软件的交付质量更高且维护成本更低；利用限界上下文来分解问题域，识别核心领域，有效分解和控制了业务的复杂度；利用 DDD 提倡的分层、六边形等架构，分离了业务复杂度和技术复杂度，使得系统具备更强的扩展性和弹性；战术层面提供了元模型（聚合，实体，值对象，服务，工厂，仓储）帮助构建清晰、稳定，能快速响应变化和新需求能力的应用；DDD 构建的应用能快速方便地切到微服务；领域驱动设计给企业应用带来的稳定性、灵活性、扩展性和应对变化的响应力对于建立灵活前台、稳固中台能带来巨大的帮助作用。

# 设计过程

领域驱动设计是一套面对复杂业务进行建模和设计的方法论和实践，建立了以领域为核心驱动力的设计体系。我们首先可以将领域设计模式分解到问题空间（Problem Space）与解空间（Solution Space）两大类中：问题空间的划分更多着眼于业务上值得注意的、重要的点；解空间则更关注与应用的组织架构，保证应用本身更易于管理。

![问题空间](https://assets.ng-tech.icu/item/20230426174819.png)

![解空间](https://assets.ng-tech.icu/item/20230427181241.png)

这里领域专家会起到关键的作用，他应该通晓研发的这个产品需要解决哪些问题，专业术语，关联关系。对于简单的业务领域，一个领域可能就是一个小的子域。领域建模过程相对简单，根据事件风暴可以分解出事件、命令、实体、聚合和限界上下文等，根据领域模型和微服务拆分原则设计出微服务即可。对于复杂的业务领域，领域可能还需要拆分为子域，甚至子域还会进一步拆分，如：保险领域可以拆分为承保、理赔、收付费和再保等子域，承保子域还可以再拆分为投保、保单管理等子子域。对于这种复杂的领域模型，是无法通过一个事件风暴完成领域建模的，即使能完成，其工程量也是非常浩大，效果也不一定好。

从领域驱动设计落地的过程中，又可以划分为战略设计与战术设计：

![战略设计与战术设计](https://assets.ng-tech.icu/item/20230426174924.png)

- 在战略设计阶段，面对纷繁复杂的业务需求，领域专家和研发团队进行紧密合作、充分沟通，进行事件风暴或场景驱动设计，分析需求并提炼知识，得到比较清晰的问题域，输出由领域专家和研发团队达成共识的统一语言（UL，Ubiquitous Language），基于统一语言对问题域进行分析和建模，识别业务边界，确定限界上下文，根据限界上下文划分独立的领域，建立限界上下文彼此之间的关系，接着引入系统上下文(System Context)确定系统的边界，并确定它的外部环境，包括与其集成的第三方系统与基础设施。利用 DDD 分层架构或六边形架构界定业务领域和技术实现的边界，让稳定的核心领域模型处于架构的最内部，避免技术实现和架构变动带来的影响。

- 接着进入战术设计阶段，一个大的业务问题被分解为多个限界上下文（问题域），团队视野和专注就可以聚焦到每一个内聚的限界上下文，进行战术设计。战术设计的重点是利用领域驱动设计的元模型对领域的复杂性进行分解和建模。领域驱动设计强调和突出了领域模型的重要性，通过整个领域驱动设计过程，绑定领域模型和技术模型，以保证领域模型和技术模型在贯穿整个软件开发的生命周期中（需求分析、建模、架构、设计、编码、测试与持续重构）的强一致性。领域模型指导着软件设计以及技术编码实现，接着通过重构实践来挖掘隐式概念，完善统一语言和模型，运用设计模式改进设计与开发质量。

以下是领域驱动设计的粗略过程：

![领域驱动设计过程](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/uPic/USXzRYaIfbeV.png)

对于这种复杂的领域，我们可以分三阶段来完成领域模型和微服务设计：

- 拆分子域建立领域模型：根据业务特点考虑流程节点或功能模块等边界因素（微服务最终的拆分结果很多时候跟这些边界因素有一定的相关性），按领域逐级分解为大小合适的子域，针对子域进行事件风暴，记录领域对象、聚合和限界上下文，初步确定各级子域的领域模型。
- 领域模型微调：梳理领域内所有子域的领域模型，对各子域模型进行微调，这个过程重点考虑不同限界上下文内聚合的重新组合，同步需要考虑子域、限界上下文以及聚合之间的边界、服务以及事件之间的依赖关系，确定最终的领域模型。
- 微服务设计和拆分：根据领域模型的限界上下文和微服务的拆分原则，完成微服务的拆分和设计。
